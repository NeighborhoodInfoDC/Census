** Locations of SAS autocall macro libraries **;

filename uiautos  "C:\Projects\UISUG\Uiautos";
filename dcautos  "C:\dcdata\SAS\Macros";
filename mcdcmac  "C:\DCData\Libraries\Census\Prog\2010\SF1\MCDC";
options sasautos=(mcdcmac dcautos uiautos sasautos);


**PT**x cd /pub/data/sf12010/Tools;  %let pgm=cnvtsf1;  filename pgm "&pgm..sas";
  *---This is the conversion program to read the SF1 data as distributed by the Census Bureau.  We read a geographic headers file and
      47 comma-delimited files in order to create observations for geogrpaphic areas.  We partition the data based on a combination of
      table-type and geographic summary levels:  seven data sets for each state.  And, at some point, seven more for the national file
      which will contain summaries for areas that (may) cross state lines.
      The 7 files  are:
       -The P & H tables for blocks only.
       -The P & H tables for bgs091 (split by mcd and place)
       -The P and H tables for bgs150 (complete bgs)
       -PCT and HCT tables  ("phctr") with a race/hispanic suffix  for all geos qualifying for CT tables.
       -Inventory summaries: all P, H, PCT and HCT (except those in phctr) for selected "inventory" geography.
       -Hierarchal summaries: like Inventory but for the remainding geography types which involve crossing two or more inventory geos.
       -The specialized PCO tables for those limited geographies to which they pertain.

      Rev. 6-18-11 to work with new set of Varlabs modules.
      Rev. 6-21-11 to fix problem reading segments 29 to 34 (tables PCT12J thru PCT12O).
      Rev. 6-28-11 to move code defining landsqmi and areasqmi up so that these variables are included in the keep list (LogRecNo--Nobsin).
      Rev. 7-07-11 to define geocode/esriid for levels 323, 324, 340, 341.

      Thanks to Nancy Gemignani  and the staff of the California State Data Center for reviewing and correcting portions of this code.
      John Blodgett,  OSEDA, under contract with the Missouri  Census Data Center.  June, 2011.
   ---*;

 %let path=/**PT**%str(/pub/data/sf12010)**/ C:\DCData\Libraries\Census\Raw\2010\SF1;
 *** libname sf12010 "/pub/data2/temp";      *<====Change this to same as path if data are NOT embargoed====;
 **PT**libname sf12010 "&path";      *<====Change this to same as path if data are NOT embargoed====;
 libname sf12010 "C:\DCData\Libraries\Census\Data\SF1test";
 libname sf1 (sf12010);   *<--allows us to sf1 as an alternate name for sf12010---;
  %let maxobs=9999999;   *<---set to smaller number to limit # of geos to process---;

 %macro select;
 %*--This macro will be invoked when reading the headers data.  It should assign a value
     of 1 to the variable _keep to indicate that the record/observation is to be processed.  _keep=1 means
     read the data, _keep=0 means do not.--;

  /*  if sumlev in ('040','050','140','150','155','871') then _keep=1; else _keep=0;   */
   *<=====************************************To convert the entire data set (default) ***********;
    _keep=1;   *--this default causes all the geographic areas to be converted--;
  %mend select;

 /**PT**%include 'tablevars.sas';**/  *---this code defines the macro variables PHvars PHCTvars PHCTRvars and PCOvars  as generated by
      the read_metadata.sas setup  and referenced in the conversion step, below.---;
 %include 'C:\DCData\Libraries\Census\Prog\2010\SF1\MCDC\tablevars.sas';  
 %let state=15;  %let stab=hi;  %let statenm=Hawaii;   *<----while testing---;
 %let state=01;  %let stab=al;  %let statenm=Alabama;   *<----while testing---;
 %macro doit(state,stab);

   %let UCstab=%upcase(&stab);

  /**PT**filename geos pipe "unzip -a -p &path/zipfiles/&stab.2010.sf1.zip &stab.geo2010.sf1";**/   %*<======NOTE=============;
  filename geos "&path\&stab.geo2010.sf1";

data
   sf12010.&stab.blocks (label="&statenm census block summaries" keep=LogRecNo--nobsin &phvars compress=binary)
   sf12010.&stab.bgs091 (label="&statenm Split block group summaries" keep=LogRecNo--nobsin &phvars compress=binary)
   sf12010.&stab.bgs150 (label="&statenm Complete block group summaries" keep=LogRecNo--nobsin &phvars compress=binary)
   sf12010.&stab.inventory(label="&statenm inventory summary levels" drop=&phctrvars &pcovars compress=binary)
   sf12010.&stab.hierarchal(label="&statenm hierarchal summary levels" drop=&phctrvars &pcovars compress=binary)
   sf12010.&stab.phctr(label="&statenm pct/hct tables repeated for race/ethnicity categories" keep=LogRecNo--nobsin &phctrvars compress=binary)
   sf12010.&stab.pcos(label="&statenm PCO tables" keep=LogRecNo--Areaname geocode esriid state stab county cbsa csa cd111 sldl sldu
        arealand--LSADC nobsin &pcovars compress=binary)   ;

  infile geos missover lrecl=1024  obs=&maxobs;
  retain _first 1;
  length LogRecno 5 GeoCode $44 esriid $40 SumLev $3 GeoComp $2 AreaName $90;  *--establish variable order -- these go first--;
  /**PT**retain State "&state" Stab "&stab";  length County $5 Tract $7;    *--and then these... -;**/
  retain State "&state" Stab "&UCstab";  length County $5 Tract $7;    *--and then these... -;
  
  if _first then do;
    input _FileId $char6. _stusab $2. @;  retain _FileId _stusab;
    if substr(_FileId,1,3) ne 'SF1' then do;
       file log;  put '******Problem with input geographic headers file.  Did not find "SF1" in cols. 2-4 ' _FileId= /
       '***Conversion will not run***';
       stop;
       end;
    _first=0;
    end;

  input
 @9   SumLev $3.  geocomp $2.
 @19  LogRecNo 7.
 @26  Region $1. Division $1.  State $2.  Cnty $3. CntyCC $2. CntySC $2.
 @37  CouSubFP $5. CouSubCC $2. CouSubSC $2. PlaceFP $5. PlaceCC $2.  PlaceSC $2.
 @55  TractIn $6.  BG $1. Block $4. @68 ConCit  $5.
 @77 aianhh $char4.  aianhhfp $char5. aianhhcc $char2. aihhtli $1. aitsce $char3. aits $char5. aitscc $char2.
 @99 ttract $6.  tblkgrp $1.     anrc $char5.  anrccc $char2.
 @113 CBSA $5. CBSASC $2. MetDiv $5. CSA $3. NECTA $5. NECTASC $2. NECTADiv $5. CNECTA $3. CBSAPCI $1.
 @145 UA $5. UASC $2. UAType $1.
 @153 UrbanRur $1. cd111 $2. (sldu sldl)($char3.) vtd $char6. vtdi $1.
 @172 ZCTA5 $5.  SubMCD $5.  SubMCDCC $2.
 @184 (SDElm SDSec SDUni)($5.)
 @199 (AreaLand AreaWatr)(14.)  AreaName $90.  FuncStat $1. gcuni $1.
 @319 Pop100 9.  HU100 9.  IntPtLat 11.7 IntPtLon 12.7 LSADC $2.
 @362 PartFlag $1.
 @476 MEMI $1. NMEMI $1. ;   ***PUMA $5. ;  *<====Note that we ignore quite a few fields here, such as all the ansi codes and all the
                   placeholders for futire values of CDs and SLDs. PUMAs are always blank (bummer). ================;
 if cnty ne ' ' then County=state||cnty;
 *--edit the tract so that it is in xxxx.xx format with leading and trailing zeroes--;
 if TractIn ne ' ' then Tract=translate( substr(TractIn,1,4)||'.'||substr(TractIn,5,2) ,'0',' ');
  drop tractin;

   *--Create land and total area values in square miles.  This code moved 6-28-11 so that it goes before nobsin.--;
 LandSQMI=AreaLand/2589988;  AreaSQMI=LandSQMI + (AreaWatr/2589988);
 format LandSQMI AreaSQMI 9.2;

  length nobsin 4;   nobsin+1;

%macro concatd(g1,g2,g3,g4,g5,g6,g7,g8); %*--utility macro used to create geocode values-;
    %*--utility macro to return a SAS expression that will be the concatenation of specified char variables
        separated by dashes-;
    %local dash  gc;  %let dash=%str(||'-'||);
    %*--we build the value of local variable gc which is then "returned" as the result of invoking the macro-;
    %let gc=&g1;          %if &g2= %then %goto rtrn;
    %let gc=&gc&dash&g2;  %if &g3= %then %goto rtrn;
    %let gc=&gc&dash&g3;  %if &g4= %then %goto rtrn;
    %let gc=&gc&dash&g4;  %if &g5= %then %goto rtrn;
    %let gc=&gc&dash&g5;  %if &g6= %then %goto rtrn;
    %let gc=&gc&dash&g6;  %if &g7= %then %goto rtrn;
    %let gc=&gc&dash&g7;  %if &g8= %then %goto rtrn;
    %let gc=&gc&dash&g8;
  %rtrn:
    &gc
    %mend concatd;

 select(SumLev);  *---Assign the standardized Geographic Code to uniquely ID the geographic area--;
   when('010') geocode=' ';
   when('020') geocode=region;
   when('030') geocode=division;
   when('040') geocode=state;
   when('050') geocode=county;
   when('060') geocode=%concatd(county,cousubfp);
   when('067') geocode=%concatd(county,cousubfp,submcd);
   when('070') geocode=%concatd(county,cousubfp,placefp);
   when('080') geocode=%concatd(county,cousubfp,placefp,tract);
   when('091') geocode=%concatd(county,cousubfp,placefp,tract,bg);
   when('101') geocode=%concatd(county,tract,block);

   when('140') geocode=%concatd(county,tract);
   when('144') geocode=%concatd(county,tract,aianhhfp);
   when('150') geocode=%concatd(county,tract,bg);
   when('154') geocode=%concatd(county,tract,bg,aianhhfp);
   when('155') do;
               geocode=%concatd(county,placefp);

   *<===Override areaname to make it the name of the place rather than the county.To leave as-is delete this + next 4 lines;
   *---to get the code used to define $&stab.place see http://mcdc2.missouri.edu/cgi-bin/uexplore?/pub/sasfmats/pl94places .
       Remembmer that &stab. here is just a reference to the state postal abbreviation in lower case, i.e. ca, ny, tx, mo, etc.  --;
               length _arg $7; _arg=state||placefp;
               drop _arg;
               areaname=put(_arg,$&stab.place.);
               if areaname=_arg then areaname='Place '||placefp;

               end;
   when('158') geocode=%concatd(state,placefp,cnty,tract);
   when('160') geocode=%concatd(state,placefp);
   when('170') geocode=%concatd(state,concit);
   when('172') geocode=%concatd(state,concit,placefp);
   when('250') geocode=aianhhfp;
   when('260') geocode=%concatd(aianhhfp,state);
   when('270') geocode=%concatd(aianhhfp,cnty);
   when('271') geocode=%concatd(aianhhfp,cnty,cousubfp);
   when('273') geocode=%concatd(aianhhfp,cnty,cousubfp,placefp);
   when('269') geocode=%concatd(aianhhfp,state,placefp);

   when('252') geocode=aianhhfp;
   when('262') geocode=%concatd(aianhhfp,state);
   when('272') geocode=%concatd(aianhhfp,county);
   when('275') geocode=%concatd(aianhhfp,county,cousubfp);
   when('276') geocode=%concatd(aianhhfp,county,cousubfp,placefp);

   when('254') geocode=aianhh;
   when('264') geocode=%concatd(aianhhfp,state);
   when('274') geocode=%concatd(aianhhfp,cnty);
   when('277') geocode=%concatd(aianhhfp,cnty,cousubfp);
   when('278') geocode=%concatd(aianhhfp,cnty,cousubfp,placefp);

   when('256','291','292') geocode=%concatd(aianhhfp,ttract);
   when('258','293','294') geocode=%concatd(aianhhfp,ttract,tblkgrp);

   when('251','253','255') geocode=%concatd(aianhhfp,aits);
   when('257') geocode=%concatd(aianhhfp,aits,ttract);
   when('259') geocode=%concatd(aianhhfp,aits,ttract,tblkgrp);
   when('290') geocode=%concatd(aianhhfp,aits,state);


   when('280','283','286') geocode=%concatd(state,aianhhfp);
   when('282','285','288') geocode=%concatd(state,aianhhfp,cnty);
   when('261','265','267') geocode=%concatd(state,aianhhfp,cnty,cousubfp);
   when('263','266','268') geocode=%concatd(state,aianhhfp,cnty,cousubfp,placefp);
   when('281','284','287') geocode=%concatd(state,aianhhfp,aits);
   when('320') geocode=%concatd(state,cbsa);
   when('321') geocode=%concatd(state,cbsa,placefp);
   when('322') geocode=%concatd(state,cbsa,cnty);
   when('323') geocode=%concatd(state,cbsa,metdiv);
   when('324') geocode=%concatd(state,cbsa,metdiv,cnty);
   when('340') geocode=%concatd(state,csa);
   when('341') geocode=%concatd(state,csa,cbsa);
   when('230') geocode=%concatd(state,anrc);
   when('500') geocode=%concatd(state,cd111);
   when('510') geocode=%concatd(state,cd111,cnty);
   when('511') geocode=%concatd(state,cd111,cnty,tract);
   when('521') geocode=%concatd(state,cd111,cnty,cousubfp);
   when('531') geocode=%concatd(state,cd111,placefp);
   when('541') geocode=%concatd(state,cd111,concit);
   when('550','551','552') geocode=%concatd(state,cd111,aianhhfp);
   when('553','554','555') geocode=%concatd(state,cd111,aianhhfp,aits);
   when('610') geocode=%concatd(state,sldu);
   when('612') geocode=%concatd(state,sldu,cnty);
   when('613') geocode=%concatd(state,sldu,cnty,cousubfp);
   when('614') geocode=%concatd(state,sldu,placefp);
   when('616', '648', '646') geocode=%concatd(state,sldu,aianhhfp);
   when('631') geocode=%concatd(state,sldu,county,tract);

   when('620') geocode=%concatd(state,sldl);
   when('622') geocode=%concatd(state,sldl,county);
   when('623') geocode=%concatd(state,sldl,county,cousubfp);
   when('624') geocode=%concatd(state,sldl,placefp);
   when('626','647','649') geocode=%concatd(state,sldl,aianhhfp);
   when('636') geocode=%concatd(state,sldl,county,tract);
   when('639') geocode=%concatd(state,sldl,anrc);

   when('860') geocode=zcta5;
   when('871') geocode=%concatd(state,zcta5);
   when('881') geocode=%concatd(state,zcta5,cnty);

   when('950') geocode=%concatd(state,sdelm);
   when('960') geocode=%concatd(state,sdsec);
   when('970') geocode=%concatd(state,sduni);
   otherwise  do;
       if sumlev ne lag(sumlev) then do;
         _badsl+1;
         if _badsl le 50 then put '**Unrecognized SUMLEV: ' sumlev;
         end;
       end;
   end;  *--select group--;
 geocode=compress(geocode,' ');  *--remove any blanks from geocode--------------;
 esriid=compress(geocode,'-.');
 %macro astab;
 %*---Adding this macro code 12-4-01 to define the stab (State Abbreviation) variable when converting a
      national file---*;
 %if %quote(&Ucstab) eq US %then %do;
   if state='  ' then stab=' ';
     else stab=put(state,$fipstab.);
   %end;
   %*--otherwise we have a retain statement above that causes variable stab to have a value of "&stab"-;
   %mend astab;
 %astab

  %select  ;  *---invokes macro that sets the _keep flag to tell the program whether or not to keep the current geo---;
  *--Set flag to indicate whether this summary level will have data for the CT tables--;
  *_readPCT= ( sumlev not in ('091','101','150','154','258','293','294','259') );   *--subtract geo summmary levels--;
  _readPCT= ( sumlev not in ('091','101','150','154') );   *--These are the sub-Census Tract levels with no "CT" tables-;
  _readPCO= ( sumlev in ('040','050','320','322','323','324','340','341','500','610','620'));
  if sumlev='040' then do;   if geocomp not in ('00','A0','C0','E0','G0','H0') then _readPCO=0;  end;
    else if geocomp ne '00' then _readPCO=0;
   attrib  PCT length=3 format=1. label='PCT data flag';
   PCT=_readPCT;   *<-----putting this back on the saved dataset 7-5-11-----;
 ***temporary diagnostic *****;  *** put geocode= _N_= areaname= sumlev= _readPCT= _readPCO=;

 format IntPtLon 11.6 IntPtLat 10.6;  *<--added 7-13-01-;

 label SumLev='Geographic Summary Level' GeoComp='Geographic Component';
 label cnty='County code';
 label LandSQMI='Land Area Sq Mls' AreaSQMI='Total Area Sq Mls'
       AreaLand='Land Area Sq Meters' AreaWatr='Water Area Sq Meters';
 label cd111='Cong District - 111th (2008)' sldu='State Leg District Upper Chbr'
       sldl='State Leg District Lower Chbr';
 label ZCTA5='ZIP Census Tabulation Area';

 *---For processing zip codes on the national files we assign the "primary" state code associated with the zip or
     zip center (zcta5 or zcta3) using the builtin SAS functions zipfips and zipstate--;
 if sumlev in ('850','860') then do;
   length _ziparg $5 ;
   if sumlev='850' then _ziparg=substr(zcta5,1,3)||'01';  else _ziparg=zcta5;
   if sumlev='860' and substr(zcta5,4,2) in ("XX","HH") then _ziparg=substr(zcta5,1,3)||'01';
   state= put ( zipfips(_ziparg), z2. );
   stab = lowcase ( zipstate(_ziparg) );
   if stab=' ' then do;
     _error_=0;
     file log;  _nziperr+1;
     if _nziperr=1 then put '****ZIP codes not assigned to states****';
     put +2 _ziparg $5.  @@;
     end;
   drop _: ;
   end;


  *---Use a length statement to set up the variables in order in the PDV (program data vector).  Then we can
      used "double-dash" variable intervals in the input statements and SAS will know
      which variables are in those intervals----*;

 *--assign the macro vars containing the first and last variables in each input file--;
    length P1i1 5;
  %let fvar1 =P1i1 ;  %let lvar1 =P1i1 ;    *<--the first and last variables on csv file ("segment") 1--;

  length P2i1-P2i6 5;
  %let fvar2 =P2i1 ;  %let lvar2 =P2i6 ;

  length P3i1-P3i8 P4i1-P4i3 P5i1-P5i17 P6i1-P6i7 P7i1-P7i15 P8i1-P8i71 P9i1-P9i73 5;
  %let fvar3 =P3i1 ;  %let lvar3 =P9i73 ;

  length P10i1-P10i71 P11i1-P11i73 P12i1-P12i49 P13i1-P13i3 P14i1-P14i43 5;
  %let fvar4 =P10i1 ;  %let lvar4 =P14i43 ;

  length P15i1-P15i17 P16i1-P16i3 P17i1-P17i3 P18i1-P18i9 P19i1-P19i19 P20i1-P20i34 P21i1-P21i31 P22i1
    -P22i21 P23i1-P23i15 P24i1-P24i11 P25i1-P25i11 P26i1-P26i11 P27i1-P27i3 P28i1-P28i16 P29i1-P29i28
     P30i1-P30i13 5;
  %let fvar5 =P15i1 ;  %let lvar5 =P30i13 ;

  length P31i1-P31i16 P32i1-P32i45 P33i1-P33i7 P34i1-P34i22 P35i1 P36i1-P36i3 P37i1-P37i3 P38i1-P38i20
     P39i1-P39i20 P40i1-P40i20 P41i1-P41i6 P42i1-P42i10 P43i1-P43i63 P44i1-P44i3 P45i1-P45i3 P46i1-P46i3
     P47i1-P47i3 P48i1-P48i3 P49i1-P49i3 5;
  %let fvar6 =P31i1 ;  %let lvar6 =P49i3 ;

  length P50i1-P50i3 P51i1-P51i3 P12Ai1-P12Ai49 P12Bi1-P12Bi49 P12Ci1-P12Ci49 P12Di1-P12Di49 P12Ei1
    -P12Ei49 5;
  %let fvar7 =P50i1 ;  %let lvar7 =P12Ei49 ;

  length P12Fi1-P12Fi49 P12Gi1-P12Gi49 P12Hi1-P12Hi49 P12Ii1-P12Ii49 P13Ai1-P13Ai3 P13Bi1-P13Bi3 P13Ci1
    -P13Ci3 P13Di1-P13Di3 P13Ei1-P13Ei3 P13Fi1-P13Fi3 P13Gi1-P13Gi3 P13Hi1-P13Hi3 P13Ii1-P13Ii3 P16Ai1
    -P16Ai3 P16Bi1-P16Bi3 P16Ci1-P16Ci3 P16Di1-P16Di3 P16Ei1-P16Ei3 P16Fi1-P16Fi3 P16Gi1-P16Gi3 P16Hi1
    -P16Hi3 P16Ii1-P16Ii3 P17Ai1-P17Ai3 5;
  %let fvar8 =P12Fi1 ;  %let lvar8 =P17Ai3 ;

  length P17Bi1-P17Bi3 P17Ci1-P17Ci3 P17Di1-P17Di3 P17Ei1-P17Ei3 P17Fi1-P17Fi3 P17Gi1-P17Gi3 P17Hi1
    -P17Hi3 P17Ii1-P17Ii3 P18Ai1-P18Ai9 P18Bi1-P18Bi9 P18Ci1-P18Ci9 P18Di1-P18Di9 P18Ei1-P18Ei9 P18Fi1
    -P18Fi9 P18Gi1-P18Gi9 P18Hi1-P18Hi9 P18Ii1-P18Ii9 P28Ai1-P28Ai16 P28Bi1-P28Bi16 P28Ci1-P28Ci16 P28Di1
    -P28Di16 P28Ei1-P28Ei16 P28Fi1-P28Fi16 P28Gi1-P28Gi16 P28Hi1-P28Hi16 P28Ii1-P28Ii16 5;
  %let fvar9 =P17Bi1 ;  %let lvar9 =P28Ii16 ;

  length P29Ai1-P29Ai28 P29Bi1-P29Bi28 P29Ci1-P29Ci28 P29Di1-P29Di28 P29Ei1-P29Ei28 P29Fi1-P29Fi28 P29Gi1
    -P29Gi28 P29Hi1-P29Hi28 P29Ii1-P29Ii28 5;
  %let fvar10=P29Ai1 ;  %let lvar10=P29Ii28 ;

  length P31Ai1-P31Ai16 P31Bi1-P31Bi16 P31Ci1-P31Ci16 P31Di1-P31Di16 P31Ei1-P31Ei16 P31Fi1-P31Fi16 P31Gi1
    -P31Gi16 P31Hi1-P31Hi16 P31Ii1-P31Ii16 P34Ai1-P34Ai22 P34Bi1-P34Bi22 P34Ci1-P34Ci22 P34Di1-P34Di22
     P34Ei1-P34Ei22 5;
  %let fvar11=P31Ai1 ;  %let lvar11=P34Ei22 ;

  length P34Fi1-P34Fi22 P34Gi1-P34Gi22 P34Hi1-P34Hi22 P34Ii1-P34Ii22 P35Ai1 P35Bi1 P35Ci1 P35Di1 P35Ei1
     P35Fi1 P35Gi1 P35Hi1 P35Ii1 P36Ai1-P36Ai3 P36Bi1-P36Bi3 P36Ci1-P36Ci3 P36Di1-P36Di3 P36Ei1-P36Ei3
     P36Fi1-P36Fi3 P36Gi1-P36Gi3 P36Hi1-P36Hi3 P36Ii1-P36Ii3 P37Ai1-P37Ai3 P37Bi1-P37Bi3 P37Ci1-P37Ci3
     P37Di1-P37Di3 P37Ei1-P37Ei3 P37Fi1-P37Fi3 P37Gi1-P37Gi3 P37Hi1-P37Hi3 P37Ii1-P37Ii3 P38Ai1-P38Ai20
     P38Bi1-P38Bi20 P38Ci1-P38Ci20 P38Di1-P38Di20 P38Ei1-P38Ei20 5;
  %let fvar12=P34Fi1 ;  %let lvar12=P38Ei20 ;

  length P38Fi1-P38Fi20 P38Gi1-P38Gi20 P38Hi1-P38Hi20 P38Ii1-P38Ii20 P39Ai1-P39Ai20 P39Bi1-P39Bi20 P39Ci1
    -P39Ci20 P39Di1-P39Di20 P39Ei1-P39Ei20 P39Fi1-P39Fi20 P39Gi1-P39Gi20 P39Hi1-P39Hi20 5;
  %let fvar13=P38Fi1 ;  %let lvar13=P39Hi20 ;

  length P39Ii1-P39Ii20 5;
  %let fvar14=P39Ii1 ;  %let lvar14=P39Ii20 ;

  length PCT1i1-PCT1i54 PCT2i1-PCT2i54 PCT3i1-PCT3i54 PCT4i1-PCT4i9 PCT5i1-PCT5i22 PCT6i1-PCT6i22 PCT7i1
    -PCT7i22 PCT8i1-PCT8i14 5;
  %let fvar15=PCT1i1 ;  %let lvar15=PCT8i14 ;

  length PCT9i1-PCT9i14 PCT10i1-PCT10i14 PCT11i1-PCT11i31 5;
  %let fvar16=PCT9i1 ;  %let lvar16=PCT11i31 ;

  length PCT12i1-PCT12i209 5;
  %let fvar17=PCT12i1 ;  %let lvar17=PCT12i209 ;

  length PCT13i1-PCT13i49 PCT14i1-PCT14i3 PCT15i1-PCT15i34 PCT16i1-PCT16i26 PCT17i1-PCT17i18 PCT18i1
    -PCT18i15 PCT19i1-PCT19i11 PCT20i1-PCT20i32 5;
  %let fvar18=PCT13i1 ;  %let lvar18=PCT20i32 ;

  length PCT21i1-PCT21i195 PCT22i1-PCT22i21 5;
  %let fvar19=PCT21i1 ;  %let lvar19=PCT22i21 ;

  length PCT12Ai1-PCT12Ai209 5;
  %let fvar20=PCT12Ai1 ;  %let lvar20=PCT12Ai209 ;

  length PCT12Bi1-PCT12Bi209 5;
  %let fvar21=PCT12Bi1 ;  %let lvar21=PCT12Bi209 ;

  length PCT12Ci1-PCT12Ci209 5;
  %let fvar22=PCT12Ci1 ;  %let lvar22=PCT12Ci209 ;

  length PCT12Di1-PCT12Di209 5;
  %let fvar23=PCT12Di1 ;  %let lvar23=PCT12Di209 ;

  length PCT12Ei1-PCT12Ei209 5;
  %let fvar24=PCT12Ei1 ;  %let lvar24=PCT12Ei209 ;

  length PCT12Fi1-PCT12Fi209 5;
  %let fvar25=PCT12Fi1 ;  %let lvar25=PCT12Fi209 ;

  length PCT12Gi1-PCT12Gi209 5;
  %let fvar26=PCT12Gi1 ;  %let lvar26=PCT12Gi209 ;

  length PCT12Hi1-PCT12Hi209 5;
  %let fvar27=PCT12Hi1 ;  %let lvar27=PCT12Hi209 ;

  length PCT12Ii1-PCT12Ii209 5;
  %let fvar28=PCT12Ii1 ;  %let lvar28=PCT12Ii209 ;

  %*---We had a problem with the code for segs 29 thru 34.  Doing a manual override here.---*;
  length PCT12Ji1-PCT12Ji209 5;
  %let fvar29=PCT12Ji1 ;  %let lvar29=PCT12Ji209 ;

  length PCT12Ki1-PCT12Ki209 5;
  %let fvar30=PCT12Ki1 ;  %let lvar30=PCT12Ki209 ;

  length PCT12Li1-PCT12Li209 5;
  %let fvar31=PCT12Li1 ;  %let lvar31=PCT12Li209 ;

  length PCT12Mi1-PCT12Mi209 5;
  %let fvar32=PCT12Mi1 ;  %let lvar32=PCT12Mi209 ;

  length PCT12Ni1-PCT12Ni209 5;
  %let fvar33=PCT12Ni1 ;  %let lvar33=PCT12Ni209 ;

  length PCT12Oi1-PCT12Oi209 5;
  %let fvar34=PCT12Oi1 ;  %let lvar34=PCT12Oi209 ;

  %*---end manual override---;

  length PCT13Ai1-PCT13Ai49 PCT13Bi1-PCT13Bi49 PCT13Ci1-PCT13Ci49 PCT13Di1-PCT13Di49 PCT13Ei1-PCT13Ei49 5;
  %let fvar35=PCT13Ai1 ;  %let lvar35=PCT13Ei49 ;

  length PCT13Fi1-PCT13Fi49 PCT13Gi1-PCT13Gi49 PCT13Hi1-PCT13Hi49 PCT13Ii1-PCT13Ii49 PCT14Ai1-PCT14Ai3
     PCT14Bi1-PCT14Bi3 PCT14Ci1-PCT14Ci3 PCT14Di1-PCT14Di3 PCT14Ei1-PCT14Ei3 PCT14Fi1-PCT14Fi3 PCT14Gi1
    -PCT14Gi3 PCT14Hi1-PCT14Hi3 PCT14Ii1-PCT14Ii3 PCT19Ai1-PCT19Ai11 PCT19Bi1-PCT19Bi11 5;
  %let fvar36=PCT13Fi1 ;  %let lvar36=PCT19Bi11 ;

  length PCT19Ci1-PCT19Ci11 PCT19Di1-PCT19Di11 PCT19Ei1-PCT19Ei11 PCT19Fi1-PCT19Fi11 PCT19Gi1-PCT19Gi11
     PCT19Hi1-PCT19Hi11 PCT19Ii1-PCT19Ii11 PCT20Ai1-PCT20Ai32 PCT20Bi1-PCT20Bi32 PCT20Ci1-PCT20Ci32
     PCT20Di1-PCT20Di32 PCT20Ei1-PCT20Ei32 5;
  %let fvar37=PCT19Ci1 ;  %let lvar37=PCT20Ei32 ;

  length PCT20Fi1-PCT20Fi32 PCT20Gi1-PCT20Gi32 PCT20Hi1-PCT20Hi32 PCT20Ii1-PCT20Ii32 PCT22Ai1-PCT22Ai21
     PCT22Bi1-PCT22Bi21 PCT22Ci1-PCT22Ci21 PCT22Di1-PCT22Di21 PCT22Ei1-PCT22Ei21 PCT22Fi1-PCT22Fi21 5;
  %let fvar38=PCT20Fi1 ;  %let lvar38=PCT22Fi21 ;

  length PCT22Gi1-PCT22Gi21 PCT22Hi1-PCT22Hi21 PCT22Ii1-PCT22Ii21 5;
  %let fvar39=PCT22Gi1 ;  %let lvar39=PCT22Ii21 ;

  length PCO1i1-PCO1i39 PCO2i1-PCO2i39 PCO3i1-PCO3i39 PCO4i1-PCO4i39 PCO5i1-PCO5i39 PCO6i1-PCO6i39 5;
  %let fvar40=PCO1i1 ;  %let lvar40=PCO6i39 ;

  length PCO7i1-PCO7i39 PCO8i1-PCO8i39 PCO9i1-PCO9i39 PCO10i1-PCO10i39 5;
  %let fvar41=PCO7i1 ;  %let lvar41=PCO10i39 ;

  length H1i1 5;
  %let fvar42=H1i1 ;  %let lvar42=H1i1 ;

  length H2i1-H2i6 5;
  %let fvar43=H2i1 ;  %let lvar43=H2i6 ;

  length H3i1-H3i3 H4i1-H4i4 H5i1-H5i8 H6i1-H6i8 H7i1-H7i17 H8i1-H8i7 H9i1-H9i15 H10i1 H11i1-H11i4 H12i1
    -H12i3 H13i1-H13i8 H14i1-H14i17 H15i1-H15i7 H16i1-H16i17 H17i1-H17i21 H18i1-H18i69 H19i1-H19i7 H20i1
    -H20i3 H21i1-H21i3 H22i1-H22i3 H11Ai1-H11Ai4 H11Bi1-H11Bi4 H11Ci1-H11Ci4 H11Di1-H11Di4 H11Ei1-H11Ei4
     H11Fi1-H11Fi4 5;
  %let fvar44=H3i1 ;  %let lvar44=H11Fi4 ;

  length H11Gi1-H11Gi4 H11Hi1-H11Hi4 H11Ii1-H11Ii4 H12Ai1-H12Ai3 H12Bi1-H12Bi3 H12Ci1-H12Ci3 H12Di1
    -H12Di3 H12Ei1-H12Ei3 H12Fi1-H12Fi3 H12Gi1-H12Gi3 H12Hi1-H12Hi3 H12Ii1-H12Ii3 H16Ai1-H16Ai17 H16Bi1
    -H16Bi17 H16Ci1-H16Ci17 H16Di1-H16Di17 H16Ei1-H16Ei17 H16Fi1-H16Fi17 H16Gi1-H16Gi17 H16Hi1-H16Hi17
     H16Ii1-H16Ii17 H17Ai1-H17Ai21 H17Bi1-H17Bi21 H17Ci1-H17Ci21 5;
  %let fvar45=H11Gi1 ;  %let lvar45=H17Ci21 ;

  length H17Di1-H17Di21 H17Ei1-H17Ei21 H17Fi1-H17Fi21 H17Gi1-H17Gi21 H17Hi1-H17Hi21 H17Ii1-H17Ii21 5;
  %let fvar46=H17Di1 ;  %let lvar46=H17Ii21 ;

  length HCT1i1-HCT1i35 HCT2i1-HCT2i13 HCT3i1-HCT3i13 HCT4i1-HCT4i13 5;
  %let fvar47=HCT1i1 ;  %let lvar47=HCT4i13 ;


  *---You can comment out or delete these  statements if you do not want or need the variable labels.
    These modules created by the read_metadata.sas module which reads a Census Bureau data dictionary file. -----*;
/**PT**   
  %include "&path/Varlabs/PHlabels.txt"/nosource2;  *--include sas label statements for the P and H tables--;
  %include "&path/Varlabs/PHCTlabels.txt"/nosource2;  *--include sas label statements for the PCT and HCT tables)--;
  %include "&path/Varlabs/PHCTRlabels.txt"/nosource2;  *--include sas label statements for the PCT tables with race/alpha sfxs)--;
  %include "&path/Varlabs/PCOlabels.txt"/nosource2;  *--include sas label statements for the PCO tables--;
**/
  %include "C:\DCData\Libraries\Census\Prog\2010\SF1\MCDC\PHlabels.txt"/nosource2;  *--include sas label statements for the P and H tables--;
  %include "C:\DCData\Libraries\Census\Prog\2010\SF1\MCDC\PHCTlabels.txt"/nosource2;  *--include sas label statements for the PCT and HCT tables)--;
  %include "C:\DCData\Libraries\Census\Prog\2010\SF1\MCDC\PHCTRlabels.txt"/nosource2;  *--include sas label statements for the PCT tables with race/alpha sfxs)--;
  %include "C:\DCData\Libraries\Census\Prog\2010\SF1\MCDC\PCOlabels.txt"/nosource2;  *--include sas label statements for the PCO tables--;


 %macro readloop;

 %local ifile i2;
 %*----loop to read from all 47 input files -- at least those that are relevant----*;
%do ifile=1 %to 47;
  %if &ifile < 10 %then %let  i2=0&ifile;  %else %let i2=&ifile;
  /**PT**filename in&ifile pipe "unzip -a -p &path/zipfiles/&stab.2010.sf1.zip &stab.000&i2.2010.sf1";**/   %*<======NOTE=============;
  filename in&ifile "&path\&stab.000&i2.2010.sf1";   
  _iseg="&i2";
  _isegck='  ';  %*--in case we do not read the segment because it is a PCT segment for a below-tract sumlev--;
  infile in&ifile  obs=&maxobs dsd missover lrecl=3000; %*<===lrecl may need to be increased for larger areas==;
   %**let file3=%substr(&&ifile,1,3);
  %***if &file3=PCT  or  &file3=HCT %then %let pctfile=1; %***else %let pctfile=0;
  %***if &file3=PCO %then %let pcofile=1;  %***else %let pcofile=0;

   %if %substr(&&fvar&ifile , 1,3) =PCT or %substr(&&fvar&ifile , 1,3) =HCT %then %let pctfile=1; %else %let pctfile=0;
   %if %substr(&&fvar&ifile , 1,3) =PCO %then %let pcofile=1; %else %let pcofile=0;


  %*--We read the variables associated with the ith input file.  Except that for certain
     summary levels and certain input files there will not be any data.  We check for
     this with the _readPCT and _readPCO flags and generate that extra conditions when we detect that
     we have a file with pct or pco variables-;
  if _keep
      %if &pctfile  %then %str( and _readPCT );
      %if &pcofile  %then %str( and _readPCO );
      then input _fileid $ _stateid $ _000 $  _isegck $2. +1 _logrecnock 7. +1
        &&fvar&ifile -- &&lvar&ifile ;    %*<--------here is where we reap reward for decaring all vars in order-;
   %if &pctfile %then %str( else if _readPCT then input; );
    %else
   %if &pcofile %then %str( else if _readPCO then input; );
    %else %str( else input;);

  if _isegck ne ' ' then link cklogrecno;

   %end;   %*--do ifile loop--------*;
   %mend readloop;

   options mprint;
   *-------------------Here is the big loop where we read up to 47 files (segments)-------------------*;
   %readloop
   ;
   _first=0;
   if _keep;  *---subsetting if.  No observation output if _keep=0---;
   *--Set tables p2 and h2 (Urban and Rural) to missing values if not the final national file.--;
     array p2(6) p2i1-p2i6;   array h2(6) h2i1-h2i6;
     do _i=2 to 5;
       p2(_i)=.;    h2(_i)=.;
       end;
   *-----output the data sets. ---------------*;
   if sumlev='101' then output sf12010.&stab.blocks;
    else if sumlev='091' then output sf12010.&stab.bgs091;
      else if sumlev='150' then output sf12010.&stab.bgs150;
       else if sumlev in ('040','050','060','140','155','160','170','280','283','285','286','281','230','320','340','360','345',
         '500','610','620','871','950','960','970') or ("&stab"="us") then output sf12010.&stab.inventory;
        else output sf12010.&stab.hierarchal;
    *--We originally had level 155 (place-county) on the hierarchal but changed our minds.  Wanted to be consistent with earlier data--;
   if _readpct then output sf12010.&stab.phctr;
   if _readpco then output sf12010.&stab.pcos;
   drop   _: ;
   return;
cklogrecno:
  if logrecno ne _logrecnock or _isegck ne _iseg then do;
     file log;
     put ///"********Problem with file synching: LogRecNo on segment " _iseg " does not match the geo headers value "
            "or segment code not expected. ******"
         /
      "Reading seg file " _iseg +1 'found segment code '  _isegck  /
      LogRecNo=  _logrecnock=  _n_= _readPCT=  _readPCO=  /
      _all_ / '******Job is aborting*********************************' ;
      stop;
      end;
   *---Diagnostic print statements are being commented out here----------------------------*;
   *file print;
   *put _n_= logrecno= _isegck= _iseg= areaname=;
   return;

   run;
    filename geos clear;
    %mend doit;

  *---the source for the dostates macro can be accessed at http://mcdc2.missouri.edu/cgi-bin/browse?/pub/sasmacro/dostates.sas@  --;
  %dostates(10,names=1);
  /**PT**
  %dostates(02 08 09 31 37,names=1);
  %dostates(06 20 42 56,names=1) ;
  %dostates(01 15,names=1)
  **/
    run;

  %File_info( data=sf12010.dehierarchal, printchar=y, freqvars=stab state sumlev )

  /**PT**%let stab=pa;   %let state=42;**/
  %let stab=de;   %let state=10;
  data sumlev_report_&stab;
  set
   sf12010.&stab.blocks (keep=sumlev state in=inblocks)
   sf12010.&stab.bgs091 (keep=sumlev state in=inbgs091)
   sf12010.&stab.bgs150 (keep=sumlev state in=inbgs150)
   sf12010.&stab.inventory(keep=sumlev state in=ini)
   sf12010.&stab.hierarchal(keep=sumlev state in=inh)
   sf12010.&stab.phctr(keep=sumlev state in=inphctr)
   sf12010.&stab.pcos(keep=sumlev state in=inpco);
   sumlevname=sumlev;  format sumlevname $sumlev.;
   if inblocks then dataset='blocks     ';  else if inbgs091 then dataset='bgs091';
    else if inbgs150 then dataset='bgs150';
    else if ini then dataset='inventory';
     else if inh then dataset='hierarchal';
    output;
   if inpco then do;  dataset='pcos';  output;  end;
   if inphctr then do;  dataset='phctr';  output;  end;
   run;
  ods html file="&pgm.&stab..html";
  ods listing close;

  proc tabulate;   by state;
   class sumlev sumlevname dataset;
   table sumlev*sumlevname all, (dataset all)*f=comma10.;
   format state $state.;
   title "Frequency Report Showing Summary Level Counts for the Datasets";
   run;
   ods html close;
  /**PT**
  *---Stricly a Missouri thing to view a contents-directory report---;
  ods html file="contdir_report.html";
  %contdir(sf12010);
   run;
  ods html close;
**/
/**PT**   %include sascode(notify);   *<---local utility for OSEDA use only.  Others can delete this line---; **/

